## PatterDesignWorkspace
这里主要的是Spring中常用的设计模式做了一些整理，设计模式多数来源于生活中问题的解决和总结，所以没有固定的应用场景，重实际概念的理解，
在spring里常用设计模式是为了解耦的，也是写了一些demo方便理解思想，在spring源码中设计模式使用的很巧妙，并且很难发现它使用了哪一种设计模式，
用这种抛砖引玉的方式，使我们在学习优秀框架的spring源码时更清晰。
### SpringAppoint：委派模式  两个角色委托人和受托人，它们中间存在重要的特点：受托人干活，委托人的问题被解决了，例如：租房中介，穷举出三个特点：
                  ①两个角色是必须的，或者一个委托人，多个受托人
                  ②让谁给办事昵：需要持有受托人的引用
                  ③中介实现的细节，只看结果是怎样
                  ④两者需要实现同一接口
### SpringFactory: 工厂模式  在demo中有写简单工厂、工厂方法、抽象工厂基本实现方式，bean在spring中BeanFactory工厂生产出来bean，我这里就不一一介绍了，工厂有两个特点：
                  ①我需要的东西，工厂可以帮我做出来，所以做的过程是隐藏了，只注重结果展现出来给我
                  ②工厂是需要一套内部规范的，才能对结果负责
  
### SpringProxy： 代理模式 一句话专业术语：代理就是对代理对象进行字节码重组；常见的事务和日志监听就是应用了。概念和委派很像，但是区别在于代理是重视过程的，它有如下3个特点：
                  ①两个角色，同上
                  ②需要知道被代理者的信息，帮忙完成这件事，
                  ③这件事一定要做，但是不能自己做，需要一个代理者来做
                cglib代理和jdk动态代理的区别：
                  ①cglib.jar和asm.jar两个包依赖才能使用
                  ② cglib可以直接面向对象进行代理，jdk动态动态代理需要面向接口（返回的是接口，不使用接口就会报类型转换异常，我试过）
                  ③ jdk动态代理类需要实现InvocationHandler重写invoke的方法并执行代理要素，cglib实现MethodInterceptor重写intercept的方法并执行代理要素
                  代理应用非常广泛，AOP的实现，日志监听等；
### SpringSinglton：单例模式 一句古语叫：上下同欲者胜，政令不一者散； 所以单例在对象开始创建到使用结束只能有一个实例存在，不然后果是功能性紊乱，假如一个人朝着一个送东西，突然接到例外一个消息，让他丢掉现在的东西，回去重新拿一个在送过去，如此往复做无用功；所以它两个特点：
                  ①从系统任务启用到结束只会有一个实例出现
                  ②这种设计是为了解决：功能性冲突时才用（我们在使用单例查询第三方结果信息时用得到）；
### SpringStrategy： 策略模式 “策略”重视的实现目标的方式方法，手段不同，但结果是相同的；这里很简单就是将可变与不变的属性方法抽取出来，分开写接口，谁符合接口的规范，谁就去实现这个接口；不变的就用基类继承就可以了，我叫这种面向接口编程，无难度吧！
### SpringTemplate: 模版模式 类似走流水线模版封装，springJdbc使用的JdbcTemplate就是一个例子，这个很熟了吧；
### SpringPrototype: 原型模式：数据都是一致的，但是实例是不一样的，这里使用jdk的clone，
                      浅克隆：能够直接拷贝其实际内容的数据类型/只支持9种,八大基本数据类型+String 浅拷贝
                      深克隆：被克隆的实例数据全数复制（包括非9种的对象），但最终还是不同的实例对象
